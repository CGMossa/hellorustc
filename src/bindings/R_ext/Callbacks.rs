/* automatically generated by rust-bindgen 0.70.1 */

/* aarch64-apple-darwin20 */
/* rustc 1.81.0 (eeb90cda1 2024-09-04) */
/* r version: 4.4.1 */

#[doc = "The signature of the C routine that a callback must implement.\nexpr - the expression for the top-level task that was evaluated.\nvalue - the result of the top-level task, i.e. evaluating expr.\nsucceeded - a logical value indicating whether the task completed properly.\nvisible - a logical value indicating whether the result was printed to the R ``console''/stdout.\ndata - user-level data passed to the registration routine."]
pub type R_ToplevelCallback = ::std::option::Option<
    unsafe extern "C" fn(
        expr: SEXP,
        value: SEXP,
        succeeded: Rboolean,
        visible: Rboolean,
        arg1: *mut ::std::os::raw::c_void,
    ) -> Rboolean,
>;
#[doc = "Linked list element for storing the top-level task callbacks."]
pub type R_ToplevelCallbackEl = _ToplevelCallback;
#[doc = "The following definitions are for callbacks to R functions and\nmethods related to user-level tables.  This was implemented in a\nseparate package formerly available from Omegahat and these\ndeclarations allow the package to interface to the internal R code.\n\nSee https://developer.r-project.org/RObjectTables.pdf."]
pub type R_ObjectTable = _R_ObjectTable;
#[doc = " Do we actually need the exists() since it is never called but R\nuses get to see if the symbol is bound to anything?"]
pub type Rdb_exists = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        canCache: *mut Rboolean,
        arg1: *mut R_ObjectTable,
    ) -> Rboolean,
>;
pub type Rdb_get = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        canCache: *mut Rboolean,
        arg1: *mut R_ObjectTable,
    ) -> SEXP,
>;
pub type Rdb_remove = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        arg1: *mut R_ObjectTable,
    ) -> ::std::os::raw::c_int,
>;
pub type Rdb_assign = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        value: SEXP,
        arg1: *mut R_ObjectTable,
    ) -> SEXP,
>;
pub type Rdb_objects =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut R_ObjectTable) -> SEXP>;
pub type Rdb_canCache = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char, arg1: *mut R_ObjectTable) -> Rboolean,
>;
pub type Rdb_onDetach = ::std::option::Option<unsafe extern "C" fn(arg1: *mut R_ObjectTable)>;
pub type Rdb_onAttach = ::std::option::Option<unsafe extern "C" fn(arg1: *mut R_ObjectTable)>;
#[doc = "Linked list element for storing the top-level task callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ToplevelCallback {
    #[doc = " the C routine to call."]
    pub cb: R_ToplevelCallback,
    #[doc = " the user-level data to pass to the call to cb()"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Called when the callback is removed."]
    pub finalizer: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a name by which to identify this element."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " the next element in the linked list."]
    pub next: *mut R_ToplevelCallbackEl,
}
#[repr(C)]
pub struct _R_ObjectTable {
    pub type_: ::std::os::raw::c_int,
    pub cachedNames: *mut *mut ::std::os::raw::c_char,
    pub active: Rboolean,
    pub exists: Rdb_exists,
    pub get: Rdb_get,
    pub remove: Rdb_remove,
    pub assign: Rdb_assign,
    pub objects: Rdb_objects,
    pub canCache: Rdb_canCache,
    pub onDetach: Rdb_onDetach,
    pub onAttach: Rdb_onAttach,
    pub privateData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ToplevelCallback"][::std::mem::size_of::<_ToplevelCallback>() - 40usize];
    ["Alignment of _ToplevelCallback"][::std::mem::align_of::<_ToplevelCallback>() - 8usize];
    ["Offset of field: _ToplevelCallback::cb"]
        [::std::mem::offset_of!(_ToplevelCallback, cb) - 0usize];
    ["Offset of field: _ToplevelCallback::data"]
        [::std::mem::offset_of!(_ToplevelCallback, data) - 8usize];
    ["Offset of field: _ToplevelCallback::finalizer"]
        [::std::mem::offset_of!(_ToplevelCallback, finalizer) - 16usize];
    ["Offset of field: _ToplevelCallback::name"]
        [::std::mem::offset_of!(_ToplevelCallback, name) - 24usize];
    ["Offset of field: _ToplevelCallback::next"]
        [::std::mem::offset_of!(_ToplevelCallback, next) - 32usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _R_ObjectTable"][::std::mem::size_of::<_R_ObjectTable>() - 96usize];
    ["Alignment of _R_ObjectTable"][::std::mem::align_of::<_R_ObjectTable>() - 8usize];
    ["Offset of field: _R_ObjectTable::type_"]
        [::std::mem::offset_of!(_R_ObjectTable, type_) - 0usize];
    ["Offset of field: _R_ObjectTable::cachedNames"]
        [::std::mem::offset_of!(_R_ObjectTable, cachedNames) - 8usize];
    ["Offset of field: _R_ObjectTable::active"]
        [::std::mem::offset_of!(_R_ObjectTable, active) - 16usize];
    ["Offset of field: _R_ObjectTable::exists"]
        [::std::mem::offset_of!(_R_ObjectTable, exists) - 24usize];
    ["Offset of field: _R_ObjectTable::get"][::std::mem::offset_of!(_R_ObjectTable, get) - 32usize];
    ["Offset of field: _R_ObjectTable::remove"]
        [::std::mem::offset_of!(_R_ObjectTable, remove) - 40usize];
    ["Offset of field: _R_ObjectTable::assign"]
        [::std::mem::offset_of!(_R_ObjectTable, assign) - 48usize];
    ["Offset of field: _R_ObjectTable::objects"]
        [::std::mem::offset_of!(_R_ObjectTable, objects) - 56usize];
    ["Offset of field: _R_ObjectTable::canCache"]
        [::std::mem::offset_of!(_R_ObjectTable, canCache) - 64usize];
    ["Offset of field: _R_ObjectTable::onDetach"]
        [::std::mem::offset_of!(_R_ObjectTable, onDetach) - 72usize];
    ["Offset of field: _R_ObjectTable::onAttach"]
        [::std::mem::offset_of!(_R_ObjectTable, onAttach) - 80usize];
    ["Offset of field: _R_ObjectTable::privateData"]
        [::std::mem::offset_of!(_R_ObjectTable, privateData) - 88usize];
};
extern "C" {
    pub fn Rf_removeTaskCallbackByIndex(id: ::std::os::raw::c_int) -> Rboolean;
    pub fn Rf_removeTaskCallbackByName(name: *const ::std::os::raw::c_char) -> Rboolean;
    pub fn R_removeTaskCallback(which: SEXP) -> SEXP;
    pub fn Rf_addTaskCallback(
        cb: R_ToplevelCallback,
        data: *mut ::std::os::raw::c_void,
        finalizer: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        name: *const ::std::os::raw::c_char,
        pos: *mut ::std::os::raw::c_int,
    ) -> *mut R_ToplevelCallbackEl;
}
